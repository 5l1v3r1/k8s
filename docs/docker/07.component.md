## 七、Docker核心技术

​	Docker采用了标准的C/S架构，包括客户端和服务端两大部分。

​	客户端可以和服务端机可以运行在一个机器，也可以通过socket或者RESTful API来进行通信。

### 7.1、服务端

​	Docker daemon一般在宿主机后台运行，作为服务端接受来自客户的请求，并处理这些请求（创建、运行、分发容器）。在设计上，Docker daemon是一个非常松耦合的架构，通过专门的ENgine模块来分发管理各个来自客户端的任务。

​	Docker服务端默认监听本地的unux:///var/run/docker.sock套接字，只允许本地的root用户访问。可以通过-H选项修改监听方式。

```
docker -H 0.0.0.0:666 -d &
```

此外，Docker还支持通过HTPPS认证方式来验证访问。

### 7.2、客户端

​	Docker客户端为用户提供了一系列可执行命令，用户通过这些命令实现与Docker daemon的交互。

​	用户使用的Docker可执行命令即为客户端程序。与Docker daemon不同的是，客户端发送命令后，等待服务端返回，一旦收到返回后，客户端立刻执行结束并退出。用户执行新的命令，需要再次调用客户端命令。

​	同样，客户端默认通过本地的unux:///var/run/docker.sock套接字向服务端发送命令。如果服务端没有监听到默认套接字，则需要客户端在执行命令的时候显式指定。

```
docker -H tcp://127.0.0.1:666 version
```

### 7.3、命名空间

​	命名空间（Namespace）是Linux内核针对实现容器虚拟化而引入的一个强大特性。

​	每个容器都可以拥有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间互不影响。

​	众所周知，在操作系统中，包括内核、文件系统、网络、PID、UID、IPC、内存、硬盘、CPU等资源，所有的资源都是应用进程直接共享的。要想实现虚拟化，除了要实现对内存、CPU、网络IO、硬盘IO、存储空间等的限制外，还要实现文件系统、网络、PID、UID、IPC等等的相互隔离。前者相对实现容易实现一些，后者则需要宿主机系统的深入支持。

​	随着Linux系统的逐步完善，已经实现让某些进程在彼此隔离的命名空间中运行，这些进程都共用一个内核和某些运行时环境（runtime），但是彼此是不可见的-它们各自认为是自己独占系统的。

#### 7.3.1、进程命名空间

​	Linux通过命名空间管理进程号，对于同一个进程（同一个task_struct），在不同的命名空间中，看到的进程号不相同，每个进程命名空间有一套自己的进程号股那里方法。进程命名空间是一个父子关系的结构，子空间中的进程对于父空间是可见的。新fork出的进程在父命名空间个子命名空间将分别由一个进程号来对应。

#### 7.3.2、网络命名空间

​	如果有了PID命名空间，那么每个名字空间中的进程就可以相互隔离，但是网络端口还是共享本地系统的端口，

​	通过网络命名空间，可以实现网络隔离。一个网络命名空间为进程提供了一个完全独立的网络协议栈的视图。包括网络设备接口、IPv4和IPv6协议栈、IP路由表】防火墙规则，Sockets等等。这样每个容器的网络就能隔离。Docker采用虚拟网络设备（Virtual Network Device）的方式，将不同命名空间的网络设备连接到一起。默认情况下，容器中的虚拟网卡将同本地主机上的docker0网桥连接在一起。

查看桥街道宿主机docker0网桥的虚拟网口：

```
brctl show
```

#### 7.3.3、IPC命名空间

​	容器中进程交互还是采用了LInux常见的进程间交互方法（Interprocess Communication IPC），包括信号量、消息队列和共享内存等。PID命名空间和IPC命名空间可以组合起来一起使用，同一个IPC名字空间内的进程可以彼此可见，允许进行交互；不同名字空间的进程则无法交互。

#### 7.3.4、挂载命名空间

​	类似chroot，将一个进程放到一个特定的目录执行。挂载命名空间运行不同命名空间的进程看到的文件结构不同，这样每个命名空间中的进程所看到的文件目录彼此隔离。

#### 7.3.5、UTS命名空间

​	UTS（UNIX Time-sharing System）命名空间允许每个容器拥有独立的主机名和域名，从而可以虚拟出一个独立主机名和网络空间的环境，就跟网络上一台独立的主机一样。

#### 7.3.6、用户命名空间

​	每个容器可以有不同的用户和组ID，也就是说可以在容器内使用特定的内部用户执行程序，而非本地系统上存在的用户。

​	每个容器内部都可以由root用户，跟宿主机不在同一个命名空间。



### 7.4、控制组

​	控制组（CGroups）是Linux内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，Docker才能避免多个容器同时运行时的系统资源竞争。

​	控制组可以提供对容器的内存、CPU、磁盘IO等资源进行限制和计费管理。控制组的设计目标是为不同的应用情况提供统一的接口，从控制单一进程（比如nice工具）到系统级虚拟化（包括OpenVZ、Linux-VServer、LXC等）。

控制组提供以下功能：

- **资源限制（Resource Limiting）**：可以设置为不超过设定的内存限制。比如内存子系统可以为进程组设定一个内存使用上限，一旦进程组使用的内存达到限额再申请内存，就会触发Out of Memory。
- **优先级（Prioritization）**：通过优先级让一些组优先得到更多的CPU、MEM等资源
- **资源审计（Accounting）**：用来统计系统实际上把多少资源用到适合的目的上，可以使用cpuacct子系统记录某个进程组使用的CPU时间
- **隔离（Isolation）**：为组隔离名字空间，这样一个组不会看到另一个组的进程、网络连接、文件系统
- **控制（Control）**：挂起、恢复和重启动等操作







