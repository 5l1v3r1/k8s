## 六、Dockerfile详解

​	镜像的定制实际上就是定制每一层所添加的配置文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来定制、构建镜像，那么无法重复、镜像构建透明性、镜像体积的问题都会解决。这个脚本就是Dockerfile。

​	Dockerfile是一个文本文件，其内包含了一条条的指令，所有指令都是在开头，并且必须为大写字母，每一条指令构建一层，因此每一条指令的内容，就是描述该层当如何构建。Dockerfile的指令会按从上到下的顺序执行。

- FROM：指定基础镜像

  所谓定制镜像，那一定是以一个镜像为基础的，在其上进行定制，而FROM就是指定基础镜像，因此Dockerfile中FROM是必备的指令，并且必须是第一条指令。

- RUN：执行命令

  RUN指令是用来执行命令行命令的，由于命令行的强大能力，RUN指令是在定制镜像时最常用的指令之一。其格式有两种：

  - shell格式：RUN <命令>，就像直接在命令行种输入的命令一样。
  - exec格式：RUN [“可执行文件”,“参数1”,"参数2"]，这更像是函数调用种的格式。

  ​      因每一条指定构建一层，当有多个shell格式的RUN指令时，尽量使用&&将各个命令串联起来，简化镜像层。Dockerfile支持shell类的行尾添加\的命令换行方式，以及行首#进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。

  ​       此外，在指令结束时务必进行缓存清理，之前说过，镜像时多层的，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定确保每一层只添加真正需要的东西，任何无关的东西都应该清理掉。很多初学者制作令很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。

- COPY：复制文件

  格式：

  - COPY <源路径> …<目标路径> 
  - COPY ["<源路径1>",..."<目标路径>"]

  ​       和RUN指令一样，也有两种格式，一种类似命令行，一种类似于函数调用。COPY指令将从构建上下文目录<源路径>的文件/目录复制到新的一层镜像内的<目标路径>指定位置。

  ​       <源路径>可以是多个，甚至可以是通配符，其通配符规则要满足GO的规则。

  ​      <目标路径>可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用WORKDIR指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。

  ​      此外，还需要注意一点，使用COPY指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。

- ADD：更高级的复制文件

  ​	ADD指令和COPY的格式和性质基本一致。但是在COPY基础上增加了一些功能。比如<源路径>可以是一个URL，这种情况下，Docker引擎会试图去下载这个链接的文件放到<目标路径>去。下载后的文件权限自动设置为600，如果这并不是想要的权限，那么还需要增加额外的一层RUN进行权限调整，另外，下载的是个压缩包，需要使用额外一层RUN进行解压缩。所以不如直接使用RUN指令，然后wget、curl下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐。

  ​	如果<源路径>为一个tar压缩文件的话，压缩格式为gzip、bzip2、xz的情况下，ADD指令将会自动解压缩。

  ​	在Docker官方文档中，ADD指令会令镜像构建缓存失效，从而可能会令镜像变得比较缓慢。因此，尽可能的使用COPY，因为COPY语义很明确，就是复制文件而已，而ADD则包含了更复杂的功能，其行为也不一定很清晰。最适合使用ADD的场合，就是自动解压缩的场合。

  

- CMD：容器启动命令

  CMD指令的格式和RUN相似，也是两种格式：

  - shell格式：CMD <命令>
  - exec格式：CMD [“可执行文件”,"参数1","参数2"...]
  - 参数列表格式：CMD ["参数1","参数2"…]。在指定了CNTRYPOINT指令后，用CMD指定具体参数。

  ​        Docker不是虚拟机，容器就是进城。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD指令就是用于指定默认的容器主进程的启动命令。在运行时可以指定新的命令来替代镜像设置中的这个默认命令。

  ​	在指令格式上，一般推荐使用exec格式，这类格式在解析时会被解析喂JSON数组，因此一定要使用双引号，而不是单引号。如果使用shell格式的话，实际的命令会被包装为`sh -c`的参数的形式进行执行。

  ​	Docker不是虚拟机，容器中的应用都应该在前台执行，而不是像虚拟机、物理机里面那样，用upstart/systemd去启动后台服务，容器内没有后台服务的概念。

  ```
  CMD ["nginx","-g","daemon off"]
  ```

  

- ENTRYPOINT：接入点

  ​	ENTRYPOINT的格式和RUN指令的格式一样，分为exec格式和shell格式。ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及参数。ENTRYPOINT在运行时也可以替代，需要通过--entrypoint来指定。

  ​	当指定来ENTRYPOINT后，CMD的含义就发生了改变，不再是直接运行其命令，而是将CMD的内容作为参数传给ENTRYPOINT指令。

- ENV：设置环境变量

  格式有两种：

  - ENV <key> <value>
  - ENV <key1>=<value1> <key2>=<value2>

  ​        这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。

- ARG：构建参数

  格式：ARG <参数名> [=<默认值]

  ​	构建参数和ENV的效果一样，都是设置环境变量。不同的是，ARG所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用ARG保存密码之类的信息，因为`docker history`还是可以看到所有值的。

  ​	Dockerfile中的ARG指令时定义参数名称，以及定义其默认值。该默认值可以在构建命令`docker build `中用`--build-arg <参数名>=<值>`来覆盖。

  ​	在1.13之前的版本，要求`--build-arg`中的参数名，必须在Dockerfile中用ARG定义过了，换句话说，就是`--build-arg`指定的参数，必须在Dockerfile中使用了。如果对应参数没有被使用，则会报错退出构建。从1.13开始，这种严格的限制被放开，不再报错退出，而是现实警告信息，并继续构建。这对于使用CI系统，用同样的构建流程构建不同的Dockerfile的时候比较有帮助，避免构建命令必须根据每个Dockerfile的内容修改。

- VOLUME：定义存储卷

  格式：

  - VOLUME ["<路径1>","<路径2>"...]
  - VOLUME <路径>

  ​        之前我们说过，容器运行时应该尽量避免容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷（volume）中，在Dockerfile中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果忘记指定挂载，其应用也可以这个正常运行，不会向容器存储层写入大量数据。

- EXPOSE：声明端口

  格式： EXPOSE <端口1> [<端口2>…]。

  ​	EXPOSE指令时声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。

- WORKDIR：指定工作目录

  格式： WORKDIR <工作目录路径>。

  ​	使用WORKDIR指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR会帮你创建目录。

- USER：指定当前用户

  格式：USER <用户名>

  ​	USER指定和WORKDIR相似，都是改变环境状态并影响以后层。WORKDIR是改变工作目录，USER则是改变之后层的执行RUN、CMD以及ENTRYPOINT这类命令的身份。

  ​	USER只是帮助你切换到指定用户而已，这个用户必须是事先创建好的，否则无法切换。

- HEALTHCHECK：健康检查

  格式：

  - HEALTHCHECK [选项] CMD <命令> ：设置检查容器健康状况的命令
  - HEALTHCHECK NONE ：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令

  ​        HEALTHCHECK指令是Docker应该如何进行判断容器的状态是否正常，这是Docker1.12引入的新指令。通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否正常，从而比较真实的反应容器实际状态。

  ​	当一个镜像指定了HEALTHCHECK指令后，用其启动容器，初始状态会为starting，在HEALTHCHECK指令检查成功后变为healthy，如果连续一定次数失败，则会变为unhealthy。

  HEALTHCHECK支持下列选项：

  - --interval=<间隔> ：两次健康检查的间隔，默认为30秒。
  - --timeout=<时长> ：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认30秒。
  - --retries=<次数> ：当连续失败指定次数后，则将容器状态视为unhealth，默认3次。

  ​       和CMD、ENTRYPOINT一样，HEALTHCHECK只可以出现一次，如果写了多个，只有最后一个生效。在`HEALTHCHECK [选项] CMD` 后面的命令，格式和ENTRYPOINT一样，分为shell格式和exec格式。命令的返回值决定了该次健康检查的成功与否：0:成功；1:失败；2:保留。不要使用这个值。

  

- ONBUILD：为他人做嫁衣

  格式：ONBUILD <其他指令>。

  ​	ONBUILD是一个特殊的指令，它后面跟的是其它指令，比如RUN、COPY等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。Dockerfile中的其它指令都是为了定制当前镜像而准备的，唯有ONBUILD是为了帮助别人定制自己而准备的。


